# -*- coding: utf-8 -*-
"""Copy of benchmarking.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pdujnnos5onNwCe2cIdFIhHOROlp6Ypl

To receive credit for this exercise, submit a .py file named "benchmarking.py" containing the code that you used to generate your datasets and create your plots. For this exercise, you may deviate from the provided skeleton code.
"""

import numpy as np
import timeit
from copy import deepcopy
import math
import random
from decimal import Decimal

samples = dict()
#You should experiment with these values
x_range = np.arange(0,80,5)
number_of_trials = 1000

"""
For the following functions, [a] and [b] are n by n matrices
"""

def my_matmul(a,b):
  n = len(a)
  result = [[0 for x in range(n)] for y in range(n)]

  for r in range(n):
    for c in range(n):
      for k in range(n):
        result[r][c] += a[r][k] * b[k][c]

  return result

def my_add(a,b):
  n = len(a)
  result = [[0 for x in range(n)] for y in range(n)]

  for r in range(n):
    for c in range(n):
      result[r][c] = a[r][c] + b[r][c]

  return result

def swap(mat, i,j):
    result = mat[::]
    result[i], result[j] = result[j], result[i]

    return result

def my_inv(a):
  n = len(a)
  a2 = deepcopy(a)
  id = identity(n)

  indices = list(range(n))

  for fd in range(n):
    pivot = 0
    for r in range(fd, n):
      pivot = a2[r][fd]
      if pivot != 0:
        swap(a2, r, fd)
        break
    fdScalar = 1.0 / pivot
    for j in range(n):
      a2[fd][j] *= fdScalar
      id[fd][j] *= fdScalar
    for i in indices[0 : fd] + indices[fd + 1: ]:
      crScalar = a2[i][fd]
      for j in range(n):
        a2[i][j] -= crScalar * a2[fd][j]
        id[i][j] -= crScalar * id[fd][j]

  return id

def identity(n):
  result = [[0 for x in range(n)] for y in range(n)]

  for i in range(n):
    result[i][i] = 1

  return result

"""
For the following functions, [n] is a positive integer denoting
the size of the matrix (n by n) on which the corresponding operation
should be time. 
"""

def create_mat(n):
  result = [[random.uniform(-100, 100) for x in range(n)] for y in range(n)]

  return result

def time_my_matmul(n):
  return timeit.timeit(lambda : my_matmul(create_mat(n), create_mat(n)), number = number_of_trials)

def time_my_add(n):
  return timeit.timeit(lambda : my_add(create_mat(n), create_mat(n)), number = number_of_trials)

def time_my_inv(n):
  return timeit.timeit(lambda : my_inv(create_mat(n)), number = number_of_trials)

def time_numpy_matmul(n):
  return timeit.timeit(lambda : np.matmul(create_mat(n), create_mat(n)), number = number_of_trials)

def time_numpy_add(n):
  return timeit.timeit(lambda : np.add(create_mat(n), create_mat(n)), number = number_of_trials)

def time_numpy_inv(n):
  if n == 0:
    return 0
  return timeit.timeit(lambda : np.linalg.inv(create_mat(n)), number = number_of_trials)

def time_numpy_solve(n):
  if n == 0:
    return 0
  return timeit.timeit(lambda : np.linalg.solve(create_mat(n), create_mat(n)), number = number_of_trials)

samples["my matrix multiplication"] = [time_my_matmul(n) for n in x_range]
samples["my matrix addition"] = [time_my_add(n) for n in x_range]
samples["my matrix inverse"] = [time_my_inv(n) for n in x_range]
samples["numpy matrix multiplication"] = [time_numpy_matmul(n) for n in x_range]
samples["numpy matrix addition"] = [time_numpy_add(n) for n in x_range]
samples["numpy matrix inverse"]  = [time_numpy_inv(n) for n in x_range]
samples["numpy matrix solve"]  = [time_numpy_solve(n) for n in x_range]

import matplotlib.pyplot as plt
  
def plot_figure(operation, times, fig):
  plt.figure(fig)
  plt.plot(times)
  plt.xlabel(operation)

fig = 0
for operation, times in samples.items():
  plot_figure(operation, times, fig)
  fig += 1
plt.show()

def plot_overlay(operation, time, p, fig, degree):
  plt.figure(fig)
  plt.plot(time, 'o', markersize = 5, label=operation)
  plt.xlabel(operation)

  print(operation, time)

  if degree == 3:
    a = [[x * x * x, 1] for x in x_range]
  elif degree == 2:
    a = [[x * x, 1] for x in x_range]
  b = time
  d = np.linalg.lstsq(a, b, rcond = 'warn')

  if degree == 3:
    y3 = [d[0][0] * x * x * x + d[0][1] for x in x_range]
  elif degree == 2:
    y3 = [d[0][0] * x * x + d[0][1] for x in x_range]
  plt.plot(y3, 'r', label = 'Least Squares Fit')

corresponding__p_value = {"my matrix addition": 1, "my matrix multiplication": 1, "my matrix inverse" : 1, "numpy matrix addition": 1, "numpy matrix multiplication": 1, "numpy matrix inverse": 1, "numpy matrix solve": 1}

fig = 0
for operation, times in samples.items():
  if operation == "my matrix multiplication" or operation == "my matrix inverse":
    degree = 3
  else:
    degree = 2 
  plot_overlay(operation, times, corresponding__p_value[operation], fig, degree)
  fig += 1
plt.show()